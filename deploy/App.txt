<!DOCTYPE html>
<html>
<head>
    <title>Super Customizable Cumulative Flow Diagram</title>
    <!--  (c) 2013 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Fri Aug 01 2014 20:48:57 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Fri Aug 01 2014 20:48:57 GMT-0700 (PDT)";
        var CHECKSUM = 20501044422;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define("Rally.TechnicalServices.CFDCalculator", {
    extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",

    config: {
    },
    /*
     * How to measure
     * 
     * { 
     *      field       : the field that has the value to add up on each day
     *      as          : the name to display in the legend
     *      display     : "line" | "column" | "area"
     *      f           : function to use (e.g., "sum", "filteredSum"
     *      filterField : (when f=filteredSum) field with values used to group by (stacks on column)
     *      filterValues: (when f=filteredSum) used to decide which values of filterField to show
     */
    getMetrics: function () {
        var allowed_values = ['Defined','In-Progress', 'Completed'];
        return [
            {
                f: 'groupBySum',
                field: 'PlanEstimate', 
                groupByField: 'ScheduleState', 
                allowedValues: allowed_values,
                display:'area'
            }/*,
            {
                f: 'groupByCount', 
                groupByField: 'ScheduleState', 
                allowedValues: allowed_values, 
                display: 'area'
            }*/
        ];
    },
    runCalculation: function (snapshots) {
        var calculatorConfig = this._prepareCalculatorConfig(),
            seriesConfig = this._buildSeriesConfig(calculatorConfig);
console.log("seriesConfig",seriesConfig);

        var calculator = this.prepareCalculator(calculatorConfig);
console.log("calculator", calculator);
        calculator.addSnapshots(snapshots, this._getStartDate(snapshots), this._getEndDate(snapshots));
console.log('result',calculator.getResults());
        var data = this._transformLumenizeDataToHighchartsSeries(calculator, seriesConfig);
console.log(data);
        return data;
    },
    _transformLumenizeDataToHighchartsSeries: function (calculator, seriesConfig) {
        var results = calculator.getResults();

        var seriesData = results.seriesData;

        var finalData = {
            series: this.lumenize.arrayOfMaps_To_HighChartsSeries(seriesData, seriesConfig),
            categories: this._buildCategoriesFromData(seriesData)
        };

        if (this.enableProjections) {
            finalData.projections = results.projections;
        }

        return finalData;
    },
    _buildSeriesConfig: function (calculatorConfig) {
        var aggregationConfig = [],
            metrics = calculatorConfig.metrics,
            derivedFieldsAfterSummary = calculatorConfig.deriveFieldsAfterSummary;

        for (var i = 0, ilength = metrics.length; i < ilength; i += 1) {
            var metric = metrics[i];
            if ( metric.f = "groupBySum" ) {
                if ( ! this.allowed_values ) {
                    throw "Rally.TechnicalServices.CFDCalculator requires setting 'allowed_values'";
                }
            } else {
                aggregationConfig.push({
                    name: metric.as || metric.field,
                    type: metric.display,
                    dashStyle: metric.dashStyle || "Solid"
                });
            }
        }

        for (var j = 0, jlength = derivedFieldsAfterSummary.length; j < jlength; j += 1) {
            var derivedField = derivedFieldsAfterSummary[j];
            aggregationConfig.push({
                name: derivedField.as,
                type: derivedField.display,
                dashStyle: derivedField.dashStyle || "Solid"
            });
        }

        return aggregationConfig;
    }
});
/**
 * a calculator for each day of data,
 * given a snap for that day, will calculate a
 * total count for each value in a metric field (e.g., count the number of items in Defined schedule state)
 * 
 * assumes that each individual snap represents one unique item
 */
 
 Ext.define('TSDay',{
    extend: 'Ext.data.Model',
    group_totals: {},
    fields: [
        {name:'JSDate',type:'date',defaultValue:new Date()},
        {name:'groupByFieldName',type:'string',defaultValue:'ScheduleState'}, /* the name of the field that filters what we count */
        {name:'metricFieldName',type:'string',defaultValue:'Count'}, /* the name of the field with a value to add (or count), remember the c_! */
        {name:'Total',type:'number',defaultVale:0}
    ],
    constructor: function(data) {
        this.group_totals = {};
        this.callParent(arguments);
    },
    /**
     * Given a single lookback snapshot, aggregate data
     * @param {} snap
     */
    addSnap: function(snap){
        var total = this.get('Total');
        var group_by_field_name = this.get('groupByFieldName');
        var metric_field_name = this.get('metricFieldName');
        
        var value_in_snap = 0;
        if ( metric_field_name === "Count" ) {
            value_in_snap = 1;
        } else {
            if (Ext.isNumber(snap.get(metric_field_name))) {
                value_in_snap = snap.get(metric_field_name);
            }
        }
        total = total + value_in_snap;
        this.set('Total',total);
        
        var snap_value = snap.get(group_by_field_name);
        
        if ( Ext.isDefined(snap_value) ) {
            if ( Ext.isBoolean(snap_value) ) { 
                if ( snap_value ) { 
                    snap_value = "true"; 
                } else { 
                    snap_value = "false"; 
                } 
            }
            
            if ( ! snap_value || snap_value == "" ) { snap_value = "None"; }
            
            if ( ! this.group_totals[snap_value] ) { this.group_totals[snap_value] = 0; }
            this.group_totals[snap_value] = this.group_totals[snap_value] + value_in_snap;
        }
    },
    /**
     * return the aggregated value of totals for a given group (as seen in the groupByFieldName
     * (assumes if we haven't heard about the field value yet, it's just 0
     */
    getGroupTotal: function(field_value){
        return this.group_totals[field_value] || 0 ;
    }
    
 });

/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.SettingsDialog',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tssettingsdialog',
    config: {
        /* default settings. pass new ones in */
        title: 'Settings',
        model_type: 'HierarchicalRequirement',
        /**
         * artifact_types
         * [ @type ] artifact_types This is the list of items allowed in the model chooser drop down
         */
        artifact_types: [
            {Name:'HierarchicalRequirement',Value:'HierarchicalRequirement'},
            {Name:'Defect',Value:'Defect'}
        ],
        group_by_field_name: 'Schedulestate',
        metric: 'Count',
        start_date:Rally.util.DateTime.add(new Date(),"month",-1),
        end_date: Rally.util.DateTime.add(new Date(),"day",-1),
        /**
         * A string to apply to choose records that are allowed in the calculations --
         * this query is applied to items as they exist now, and then all the calculations are
         * about only those records as they were during the time period.  
         * 
         * This can make everything slow, because it adds a WsapiCall on top of the LookBack calls
         */
         query_string: null
    },
    items: {
        xtype: 'panel',
        border: false,
        defaults: {
            padding: 5,
            margin: 5
        },
        items: [
            {
                xtype: 'container',
                itemId: 'model_selector_box'
            },
            {
                xtype:'container',
                itemId: 'group_field_selector_box'
            },
            {
                xtype:'container',
                itemId: 'metric_selector_box'
            },
            {
                xtype:'container',
                itemId:'start_date_selector_box'
            },
            {
                xtype:'container',
                itemId:'end_date_selector_box'
            },
            {
                xtype:'container',
                itemId:'query_selector_box'
            }
        ]
    },
    constructor: function(config){
        this.mergeConfig(config);
        this.callParent([this.config]);
        
    },
    initComponent: function() {
        this.callParent(arguments);
        this.addEvents(
            /**
             * @event settingsChosen
             * Fires when user clicks done after making settings choices
             * @param {Rally.technicalservices.SettingsDialog} this
             * @param {hash} config settings
             */
            'settingsChosen',
            /**
             * @event cancelChosen
             * Fires when user clicks the cancel button
             */
            'cancelChosen'
        );
        this._buildButtons();
        this._addChoosers();
    },
    _buildButtons: function() {
        this.down('panel').addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    text: 'Run',
                    scope: this,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('settingsChosen', this, this._getConfig());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    handler: function() {
                        this.fireEvent('cancelChosen');
                        this.close()
                    },
                    scope: this
                }
            ]
        });
    },
    _getConfig: function() {
        var config = {};
        if ( this.down('#model_chooser') ) {
            config.model_type = this.down('#model_chooser').getValue();
        }
        if ( this.down('#group_field_chooser') ) {
            config.group_by_field_name = this.down('#group_field_chooser').getValue();
            config.group_by_field_type = this.down('#group_field_chooser').getRecord().get('fieldDefinition').attributeDefinition.AttributeType;
        }
        if ( this.down('#metric_chooser') ) {
            config.metric = this.down('#metric_chooser').getValue();
        }
        
        if ( this.down('#start_date_chooser') ) {
            config.start_date = this.down('#start_date_chooser').getValue();
        }
        if ( this.down('#end_date_chooser') ) {
            config.end_date = this.down('#end_date_chooser').getValue();
        }
        if ( this.down('#query_chooser') ) {
            config.query_string = this.down('#query_chooser').getValue();
        }
        return config;
    },
    _addChoosers: function() {
        var me = this;
        this._addModelChooser();
        this._addGroupChooser();
        this._addMetricChooser();
        this._addDateChoosers();
        this._addQueryChooser();
        
    },
    _addModelChooser: function() {
        var me = this;
        var type_store = Ext.create('Rally.data.custom.Store',{
            data: me.artifact_types
        });
        this.down('#model_selector_box').add({
            xtype:'rallycombobox',
            itemId: 'model_chooser',
            displayField: 'Name',
            valueField: 'Value',
            store: type_store,
            fieldLabel: 'Artifact Type',
            labelWidth: 75,
            value: me.model_type,
            listeners: {
                scope: this,
                change: function(cb,new_value){
                    this.model_type = new_value;
                    this.group_by_field_name = null;
                    this.metric = "Count";
                    this._addGroupChooser();
                    this._addMetricChooser();
                }
            }
        });
    },
    _addGroupChooser: function() {
        var me = this;
        
        this.down('#group_field_selector_box').removeAll();
        var cb = this.down('#group_field_selector_box').add({
            xtype:'rallyfieldcombobox',
            itemId: 'group_field_chooser',
            model: me.model_type,
            value: me.group_by_field_name,
            labelWidth: 75,
            fieldLabel: 'Group By'
        });
        var field_store = cb.getStore();
        field_store.on({
            'load': {
                fn: function(store,records) {
                    me._filterOutExceptChoices(store,records);
                    if ( me.group_by_field_name === null ) {
                        cb.setValue(store.getAt(0));
                    }
                },
             'scope': me
            }
        });

    },
    _addMetricChooser: function() {
        var me = this;
        
        this.down('#metric_selector_box').removeAll();
        var cb = this.down('#metric_selector_box').add({
            xtype:'rallyfieldcombobox',
            itemId: 'metric_chooser',
            model: me.model_type,
            value: me.metric,
            labelWidth: 75,
            fieldLabel: 'Measure'
        });
        var field_store = cb.getStore();
        field_store.on('load',this._filterOutExceptNumbers,this,true);
        field_store.on({
            'load':{
                fn: function() { 
                    field_store.add({name:'Count',value:'Count',fieldDefinition:{}});
                    cb.setValue(me.metric);
                },
                single: true
            }
        });
    },
    _addDateChoosers: function() {
        var me = this;
        this.down('#start_date_selector_box').add({
            xtype: 'rallydatefield',
            fieldLabel: 'Start Date',
            itemId: 'start_date_chooser',
            labelWidth: 75,
            value: me.start_date,
            validator: me._dateValidator
        });
        
        this.down('#end_date_selector_box').add({
            xtype: 'rallydatefield',
            fieldLabel: 'End Date',
            itemId:'end_date_chooser',
            labelWidth: 75,
            value: me.end_date,
            validator: me._dateValidator
        });
    },
    _addQueryChooser: function() {
        var me = this;
        this.down('#query_selector_box').add({
            xtype:'textareafield',
            grow: true,
            itemId:'query_chooser',
            labelAlign: 'top',
            fieldLabel:'Limit to items that currently meet this query filter',
            value: me.query_string
        });
    },
    _dateValidator: function(value) {
        return true;
    },
    _filterOutExceptChoices: function(store,records) {
        store.filter([{
            filterFn:function(field){ 
                var attribute_type = field.get('fieldDefinition').attributeDefinition.AttributeType;
                if (  attribute_type == "BOOLEAN" ) {
                    return true;
                }
                if ( attribute_type == "STRING" || attribute_type == "STATE" ) {
                    if ( field.get('fieldDefinition').attributeDefinition.Constrained ) {
                        return true;
                    }
                }
                if ( field.get('name') === 'State' ) { 
                    return true;
                }
                //console.log(field.get('name'),field.get('fieldDefinition').attributeDefinition.AttributeType);
                return false;
            } 
        }]);
    },
    _filterOutExceptNumbers: function(store,records) {
        store.filter([{
            filterFn:function(field){ 
                var attribute_type = field.get('fieldDefinition').attributeDefinition.AttributeType;
                if (  attribute_type == "QUANTITY" || attribute_type == "INTEGER" || attribute_type == "DECIMAL" ) {
                    return true;
                }
                if ( field.get('name') == 'Count' ) { return true; }
                return false;
            } 
        }]);
    }
    
});
Ext.define('TSStringFilter',{
    extend: 'Rally.data.QueryFilter',
    config: {
        query_string: ''
    },
    constructor: function(config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },
    _createQueryString: function(property, operator, value) {
        this.filter = this.fromQueryString(this.query_string);
        return this.filter.toString();
    },
    /**
     * Converts a query string into a Rally compatible QueryFilter
     * @static
     * @param {String} query The query string to convert into a QueryFilter
     * @return {Rally.data.wsapi.Filter} A Rally.data.wsapi.Filter that will convert back to a query string if toString() is called
     */
    fromQueryString: function (query) {
        var parser = Ext.create('Rally.data.util.QueryStringParser', {
            string: query
        });

        var initial_expression = parser.parseExpression();
        return initial_expression;
    }
});
Ext.override(Rally.data.util.QueryStringParser,{
  applyOperators: function (operators, operator) {
        if (!operators.length) {
            return this.parseNextTerm();
        }

        if (!operator) {
            operator = operators[0];
        }

        var property = this.applyOperators(operators.slice(1));

        while (this.peek() === operator) {
            this.consume(operator);
            var value = this.applyOperators(operators.slice(1));
            if ( operator == "AND" || operator == "OR" ) {
                property = Ext.create('Rally.data.QueryFilter', {
                    property: property,
                    operator: operator,
                    value: this._convertToType(value)
                });
            } else {
                value = this._convertKeywords(property,operator,value);
                if (typeof(value) == "object" ) {
                    property = value;
                } else {
                    property = Ext.create('Rally.data.QueryFilter', {
                        property: property,
                        operator: operator,
                        value: this._convertToType(value)
                    });
                }
            }
        }
        return property;
    },
    /**
     * Do date math
     **/
    _convertKeywords: function(property,operator,value) {
        var xform_value = value;
        if ( operator != "AND" && operator != "OR" ) {
            if ( this._isDateKeyword(value) ) {
                var base_js_date = this._getBaseJSDate(value);
                if ( operator == "<" || operator == ">" || operator == ">=") {
                    xform_value = this._getIsoMidnight(base_js_date);
                } else if ( operator == "<=") {
                    xform_value = this._getIsoMidnight(Rally.util.DateTime.add(base_js_date,"day",1));
                } else if ( operator == "=" ) {
                    // yesterday and tomorrow do NOT include today, but all others do
                    if ( value == "tomorrow" || value == "yesterday" || value == "today") {
                        xform_value = Ext.create('Rally.data.QueryFilter', {
                            property: property,
                            operator: ">",
                            value: this._getIsoMidnight(base_js_date)
                        }).and(Ext.create('Rally.data.QueryFilter', {
                            property: property,
                            operator: "<",
                            value: this._getIsoMidnight(Rally.util.DateTime.add(base_js_date,"day",1))
                        }));                        
                    } else {
                        // everything less than today
                        var date_1 = base_js_date;
                        var date_2 = new Date();
                        
                        if ( date_1 > date_2 ) {
                            // include today by starting at beginning of day
                            xform_value = Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: ">",
                                value: this._getIsoMidnight(date_2)
                            }).and(Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: "<",
                                value: this._getIsoMidnight(date_1)
                            }));
                        } else {
                            // include today by starting at end of day when going back
                            xform_value = Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: ">",
                                value: this._getIsoMidnight(date_1)
                            }).and(Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: "<",
                                value: this._getIsoMidnight(Rally.util.DateTime.add(date_2,"day",1))
                            }));
                        }
                    }
                }
            }
        } 
        return xform_value;
    },
    _getBaseJSDate: function(keyword){
        var lc_keyword = Ext.util.Format.lowercase(keyword);
        var today = new Date();
        return Rally.util.DateTime.add(today,"day",this.periodShifters[lc_keyword]);
    },
    _isDateKeyword: function(keyword) {
        var isKeyword = false;
        var valid_keywords = [
            "today", "tomorrow", "yesterday",
            "lastweek","lastmonth","lastquarter","lastyear",
            "nextweek","nextmonth","nextquarter","nextyear"
        ];
        if ( Ext.Array.indexOf(valid_keywords,Ext.util.Format.lowercase(keyword)) > -1 ) {
            isKeyword = true;
        }
        return isKeyword;
    },
    periodShifters: {
        "today": 0,
        "tomorrow":1, 
        "yesterday":-1,
        "lastweek":-6,
        "lastmonth":-29,
        "lastquarter":-89,
        "lastyear":-364,
        "nextweek":7,
        "nextmonth":30,
        "nextquarter":90,
        "nextyear":365       
    },
    /**
     * 
     */
    _getIsoMidnight: function(js_date) {
        var js_at_midnight = new Date(Ext.clone(js_date).setHours(0,0,0,0));
        var iso_at_midnight = Rally.util.DateTime.toIsoString(js_at_midnight).replace(/T.*$/,"");
        return iso_at_midnight;
    }
});
Ext.define('Rally.technicalservices.util.Utilities', {
    singleton: true,
    hashToArray: function(hash) {
        var result = [];
        for ( var key in hash ) {
            result.push(hash[key]);
        }
        return result;
    },
    daysBetween: function(begin_date_js,end_date_js,skip_weekends){

        if ( typeof(begin_date_js) == "string" ) {
            begin_date_js = Rally.util.DateTime.fromIsoString(begin_date_js);
        }
        if ( typeof(end_date_js) == "string" ) {
            end_date_js = Rally.util.DateTime.fromIsoString(end_date_js);
        }
        
        var dDate1 = Ext.clone(begin_date_js).setHours(0,0,0,0);
        var dDate2 = Ext.clone(end_date_js).setHours(0,0,0,0);
        
        if ( dDate1 == dDate2 ) { return 0; }
        if (typeof dDate1 === "number") { dDate1 = new Date(dDate1); }
        if (typeof dDate2 === "number") { dDate2 = new Date(dDate2); }
            
        if ( !skip_weekends ) {
            return Math.abs( Rally.util.DateTime.getDifference(dDate1,dDate2,'day') );
        } else {
            // from the sOverflow
            var iWeeks, iDateDiff, iAdjust = 0;
            if (dDate2 < dDate1) 
            { 
                var x = dDate2;
                dDate2 = dDate1;
                dDate1 = x;
            }
            var iWeekday1 = dDate1.getDay(); // day of week
            var iWeekday2 = dDate2.getDay();
            iWeekday1 = (iWeekday1 == 0) ? 7 : iWeekday1; // change Sunday from 0 to 7
            iWeekday2 = (iWeekday2 == 0) ? 7 : iWeekday2;
            if ((iWeekday1 > 5) && (iWeekday2 > 5)) iAdjust = 1; // adjustment if both days on weekend
            iWeekday1 = (iWeekday1 > 5) ? 5 : iWeekday1; // only count weekdays
            iWeekday2 = (iWeekday2 > 5) ? 5 : iWeekday2;
    
            // calculate differnece in weeks (1000mS * 60sec * 60min * 24hrs * 7 days = 604800000)
            iWeeks = Math.floor((dDate2.getTime() - dDate1.getTime()) / 604800000)
    
            if (iWeekday1 <= iWeekday2) {
              iDateDiff = (iWeeks * 5) + (iWeekday2 - iWeekday1)
            } else {
              iDateDiff = ((iWeeks + 1) * 5) - (iWeekday1 - iWeekday2)
            }
    
            iDateDiff -= iAdjust // take into account both days on weekend
    
            if ( iDateDiff < 0 ) { iDateDiff = 0; }
            return (iDateDiff); 
        }
    },

    isWeekday: function(check_date) {
        var weekday = true;
        var day = check_date.getDay();
        
        if ( day === 0 || day === 6 ) {
            weekday = false;
        }
        return weekday;
    },
    
    /*
     * compress size is the point at which to move to weeks instead of days
     */
    arrayOfDaysBetween: function(begin_date_js, end_date_js, skip_weekends, compress_size ) {
        var the_array = [];
        if ( typeof(begin_date_js) == "string" ) {
            begin_date_js = Rally.util.DateTime.fromIsoString(begin_date_js);
        }
        if ( typeof(end_date_js) == "string" ) {
            end_date_js = Rally.util.DateTime.fromIsoString(end_date_js);
        }
        if ( begin_date_js > end_date_js ) {
            var swap_holder = end_date_js;
            end_date_js = begin_date_js;
            begin_date_js = swap_holder;
        }
                
        var dDate1 = Ext.clone(begin_date_js).setHours(0,0,0,0);
        var dDate2 = Ext.clone(end_date_js).setHours(0,0,0,0);
        
        var number_of_days = this.daysBetween(begin_date_js,end_date_js,skip_weekends);
        
        var add_value = 1;
        var add_unit = 'day';
        
        if ( Ext.isNumber(compress_size) && number_of_days > compress_size ) {
            add_value = 7;
        }
        
        if ( number_of_days <= 2 ) {
            add_value = 30;
            add_unit = 'minute';
            dDate2 = Ext.clone(end_date_js).setHours(23,59,0,0);
        }
       
        
        var check_date = new Date(dDate1);
        
        while (check_date <= dDate2) {
            if ( !skip_weekends || this.isWeekday(check_date) || add_value === 7 || add_unit == 'minute' ) {
                the_array.push(check_date);
            }
            check_date = Rally.util.DateTime.add(check_date,add_unit,add_value);
        }
        
        return the_array;
    }
    
});
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [
        {xtype:'container',itemId:'message_box',tpl:'Hello, <tpl>{_refObjectName}</tpl>'},
        {xtype:'container',itemId:'display_box'},
        {xtype:'tsinfolink'}
    ],
    launch: function() {
        var project = this.getContext().getProject().ObjectID;
        
        this.down('#display_box').add({
            xtype:'rallychart',
            storeType: 'Rally.data.lookback.SnapshotStore',
            calculatorType: 'Rally.TechnicalServices.CFDCalculator',
            calculatorConfig: {
                granularity: 'month',
                startDate: "2013-12-01T00:00:00.000Z",
                tz: "America/Anchorage"
            },
            storeConfig: {
                filters: [
                    {property:'_TypeHierarchy',value:"HierarchicalRequirement"},
                    {property:'_ProjectHierarchy', value:project}
                ],
                hydrate: ["ScheduleState"],
                fetch: ["ScheduleState","PlanEstimate"]
            },
            chartConfig: {
                 chart: {
                     zoomType: 'xy'
                 },
                 title: {
                     text: 'my chart'
                 },
                 xAxis: {
                     tickmarkPlacement: 'on',
                     tickInterval: 1,
                     title: {
                         text: 'Months'
                     }
                 },
                 yAxis: [
                     {
                         title: {
                             text: 'Count'
                         }
                     }
                 ]
            }
        });
    }
});

/**
 * the loading mask wasn't going away!
 */

Ext.override(Rally.ui.chart.Chart,{
    onRender: function () {
        this.callParent(arguments);
        this._unmask();
    }
});
            
               Rally.launchApp('CustomApp', {
                   name: 'Super Customizable Cumulative Flow Diagram'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width:5%;
}
    </style>

</head>
<body></body>
</html>